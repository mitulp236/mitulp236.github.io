{"pageProps":{"post":{"mdxSource":{"compiledSource":"\"use strict\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", {\n    \"id\": \"project-requirements\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#project-requirements\",\n    \"aria-hidden\": \"true\",\n    \"tabIndex\": -1\n  }, mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"icon icon-link\"\n  })), \"Project Requirements:\"), mdx(\"p\", null, \"In our client's project, we were tasked with developing a comprehensive chat module. The requirements included functionalities such as one-to-one, group, and community chat, where all users could participate without strict limitations on joining specific chat channels.\"), mdx(\"h2\", {\n    \"id\": \"architecture-choices\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#architecture-choices\",\n    \"aria-hidden\": \"true\",\n    \"tabIndex\": -1\n  }, mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"icon icon-link\"\n  })), \"Architecture Choices:\"), mdx(\"p\", null, \"To meet these requirements, we opted for PubNub as our messaging infrastructure. We structured our system to assign a single PubNub channel for each one-to-one chat. We utilized a single channel for group chats and a separate channel for community discussion groups. Additionally, we implemented PubNub channel groups to simplify subscription management for each user.\"), mdx(\"h2\", {\n    \"id\": \"problem-1-adding-channels-to-channel-groups\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#problem-1-adding-channels-to-channel-groups\",\n    \"aria-hidden\": \"true\",\n    \"tabIndex\": -1\n  }, mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"icon icon-link\"\n  })), \"Problem 1: Adding Channels to Channel Groups:\"), mdx(\"p\", null, \"A significant hurdle we encountered was the limitation on the number of channels that can be added to a PubNub channel group. While the maximum limit is set at 2000 channels (PubNub officials recommended a more conservative 1500), surpassing this limit can lead to unpredictable outcomes. If we exceed the maximum channel limit within a PubNub channel group, the system may not generate an error message despite displaying a successful outcome. However, there's a possibility that the operation failed silently, leaving uncertainty about whether the channel was actually added to the group. To ensure accuracy, we must subsequently make an additional call to the PubNub SDK to retrieve a list of registered channels within the channel group. This necessity for a separate verification step adds complexity to the process, highlighting potential shortcomings in the system's reliability.\"), mdx(\"h2\", {\n    \"id\": \"problem-2-device-token-registration-for-push-notifications\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#problem-2-device-token-registration-for-push-notifications\",\n    \"aria-hidden\": \"true\",\n    \"tabIndex\": -1\n  }, mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"icon icon-link\"\n  })), \"Problem 2: Device Token Registration for Push Notifications:\"), mdx(\"p\", null, \"PubNub offers built-in push notification services, which initially seemed promising. However, we faced challenges when registering device tokens for users with numerous chat interactions. Essentially, we're required to input our cloud messaging credentials and other iOS push notification details into the PubNub dashboard for managing push notifications. Once configured, PubNub handles the delivery of push notifications. To activate push notifications for a specific channel, we must supply the device tokens to the corresponding PubNub channel, enabling notifications for any messages received in that channel.\"), mdx(\"p\", null, \"However, a significant challenge arises when dealing with users engaged in multiple chat interactions, including one-to-one, group, and other chats. This results in numerous PubNub channels associated with a single user. Consequently, we're compelled to register multiple PubNub channels for each token of a user separately. Unfortunately, there's no functionality available to simultaneously register multiple channels or a channel group when registering device tokens. Consequently, this leads to excessive backend calls from our system to PubNub servers, impacting system performance and efficiency.\"), mdx(\"h2\", {\n    \"id\": \"problem-3-channel-manipulations-in-device-token-flow\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#problem-3-channel-manipulations-in-device-token-flow\",\n    \"aria-hidden\": \"true\",\n    \"tabIndex\": -1\n  }, mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"icon icon-link\"\n  })), \"Problem 3: Channel Manipulations in Device Token Flow:\"), mdx(\"p\", null, \"Handling registered channels for push notifications turned out to be quite challenging. Imagine we've added 2000 channels to one device token. Now, if we want to stop notifications for some channels or remove them altogether, there's a bit of a problem. We can't just take channels off the token directly. Instead, we have to fetch from PubNub which channels are on the token, and then we have to make another call to remove the ones we don't want. Here's the kicker: when we fetch the channels on the token, we only get the first 500. There's no way to get the rest. No pagination\\u2014just the first 500, plain and simple.\"), mdx(\"h2\", {\n    \"id\": \"problem-4-pubnub-api-constraints\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#problem-4-pubnub-api-constraints\",\n    \"aria-hidden\": \"true\",\n    \"tabIndex\": -1\n  }, mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"icon icon-link\"\n  })), \"Problem 4: PubNub API Constraints:\"), mdx(\"p\", null, \"Another limitation we faced was the payload size restriction of 32KB for PubNub API operations. This constraint posed challenges when sending messages or performing channel manipulations, impacting the scalability of our chat system. Furthermore, encountering errors when making concurrent PubNub calls added complexity and reduced system reliability.\"), mdx(\"h2\", {\n    \"id\": \"conclusion\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#conclusion\",\n    \"aria-hidden\": \"true\",\n    \"tabIndex\": -1\n  }, mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"icon icon-link\"\n  })), \"Conclusion:\"), mdx(\"p\", null, \"While PubNub may suffice for smaller-scale use cases, it falls short when building robust and scalable chat systems. Limitations in channel management, push notification registration, and API constraints hinder the effectiveness of PubNub in complex environments. Improved documentation and logging mechanisms are needed to enhance developer experience and mitigate these challenges. As we navigate these limitations, we explore alternative solutions better suited to meet the demands of our project's scale and complexity.\"));\n}\n\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"<h2 id=\"project-requirements\"><a href=\"#project-requirements\" aria-hidden=\"true\" tabindex=\"-1\"><span class=\"icon icon-link\"></span></a>Project Requirements:</h2><p>In our client&#x27;s project, we were tasked with developing a comprehensive chat module. The requirements included functionalities such as one-to-one, group, and community chat, where all users could participate without strict limitations on joining specific chat channels.</p><h2 id=\"architecture-choices\"><a href=\"#architecture-choices\" aria-hidden=\"true\" tabindex=\"-1\"><span class=\"icon icon-link\"></span></a>Architecture Choices:</h2><p>To meet these requirements, we opted for PubNub as our messaging infrastructure. We structured our system to assign a single PubNub channel for each one-to-one chat. We utilized a single channel for group chats and a separate channel for community discussion groups. Additionally, we implemented PubNub channel groups to simplify subscription management for each user.</p><h2 id=\"problem-1-adding-channels-to-channel-groups\"><a href=\"#problem-1-adding-channels-to-channel-groups\" aria-hidden=\"true\" tabindex=\"-1\"><span class=\"icon icon-link\"></span></a>Problem 1: Adding Channels to Channel Groups:</h2><p>A significant hurdle we encountered was the limitation on the number of channels that can be added to a PubNub channel group. While the maximum limit is set at 2000 channels (PubNub officials recommended a more conservative 1500), surpassing this limit can lead to unpredictable outcomes. If we exceed the maximum channel limit within a PubNub channel group, the system may not generate an error message despite displaying a successful outcome. However, there&#x27;s a possibility that the operation failed silently, leaving uncertainty about whether the channel was actually added to the group. To ensure accuracy, we must subsequently make an additional call to the PubNub SDK to retrieve a list of registered channels within the channel group. This necessity for a separate verification step adds complexity to the process, highlighting potential shortcomings in the system&#x27;s reliability.</p><h2 id=\"problem-2-device-token-registration-for-push-notifications\"><a href=\"#problem-2-device-token-registration-for-push-notifications\" aria-hidden=\"true\" tabindex=\"-1\"><span class=\"icon icon-link\"></span></a>Problem 2: Device Token Registration for Push Notifications:</h2><p>PubNub offers built-in push notification services, which initially seemed promising. However, we faced challenges when registering device tokens for users with numerous chat interactions. Essentially, we&#x27;re required to input our cloud messaging credentials and other iOS push notification details into the PubNub dashboard for managing push notifications. Once configured, PubNub handles the delivery of push notifications. To activate push notifications for a specific channel, we must supply the device tokens to the corresponding PubNub channel, enabling notifications for any messages received in that channel.</p><p>However, a significant challenge arises when dealing with users engaged in multiple chat interactions, including one-to-one, group, and other chats. This results in numerous PubNub channels associated with a single user. Consequently, we&#x27;re compelled to register multiple PubNub channels for each token of a user separately. Unfortunately, there&#x27;s no functionality available to simultaneously register multiple channels or a channel group when registering device tokens. Consequently, this leads to excessive backend calls from our system to PubNub servers, impacting system performance and efficiency.</p><h2 id=\"problem-3-channel-manipulations-in-device-token-flow\"><a href=\"#problem-3-channel-manipulations-in-device-token-flow\" aria-hidden=\"true\" tabindex=\"-1\"><span class=\"icon icon-link\"></span></a>Problem 3: Channel Manipulations in Device Token Flow:</h2><p>Handling registered channels for push notifications turned out to be quite challenging. Imagine we&#x27;ve added 2000 channels to one device token. Now, if we want to stop notifications for some channels or remove them altogether, there&#x27;s a bit of a problem. We can&#x27;t just take channels off the token directly. Instead, we have to fetch from PubNub which channels are on the token, and then we have to make another call to remove the ones we don&#x27;t want. Here&#x27;s the kicker: when we fetch the channels on the token, we only get the first 500. There&#x27;s no way to get the rest. No paginationâ€”just the first 500, plain and simple.</p><h2 id=\"problem-4-pubnub-api-constraints\"><a href=\"#problem-4-pubnub-api-constraints\" aria-hidden=\"true\" tabindex=\"-1\"><span class=\"icon icon-link\"></span></a>Problem 4: PubNub API Constraints:</h2><p>Another limitation we faced was the payload size restriction of 32KB for PubNub API operations. This constraint posed challenges when sending messages or performing channel manipulations, impacting the scalability of our chat system. Furthermore, encountering errors when making concurrent PubNub calls added complexity and reduced system reliability.</p><h2 id=\"conclusion\"><a href=\"#conclusion\" aria-hidden=\"true\" tabindex=\"-1\"><span class=\"icon icon-link\"></span></a>Conclusion:</h2><p>While PubNub may suffice for smaller-scale use cases, it falls short when building robust and scalable chat systems. Limitations in channel management, push notification registration, and API constraints hinder the effectiveness of PubNub in complex environments. Improved documentation and logging mechanisms are needed to enhance developer experience and mitigate these challenges. As we navigate these limitations, we explore alternative solutions better suited to meet the demands of our project&#x27;s scale and complexity.</p>","scope":{}},"frontMatter":{"wordCount":665,"readingTime":{"text":"4 min read","minutes":3.315,"time":198900,"words":663},"slug":"problems-with-pubnub","fileName":"problems-with-pubnub.md","title":"Problems with PubNub: A Deep Dive into Chat System Challenges","date":"2024-02-25","tags":["Tech","PubNub","Chat"],"draft":false,"summary":"In our client's project, we were tasked with developing a comprehensive chat module. The requirements included functionalities such as one-to-one, group, and community chat, where all users could participate without strict limitations on joining specific chat channels."}},"prev":null,"next":null},"__N_SSG":true}